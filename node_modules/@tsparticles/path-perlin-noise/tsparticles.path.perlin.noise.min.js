/*! For license information please see tsparticles.path.perlin.noise.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine","@tsparticles/perlin-noise"],t);else{var i="object"==typeof exports?t(require("@tsparticles/engine"),require("@tsparticles/perlin-noise")):t(e.window,e.window);for(var o in i)("object"==typeof exports?exports:e)[o]=i[o]}}(this,((e,t)=>(()=>{var i={303:t=>{t.exports=e},846:e=>{e.exports=t}},o={};function s(e){var t=o[e];if(void 0!==t)return t.exports;var n=o[e]={exports:{}};return i[e](n,n.exports,s),n.exports}s.d=(e,t)=>{for(var i in t)s.o(t,i)&&!s.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{s.r(n),s.d(n,{loadPerlinNoisePath:()=>l,perlinNoisePathName:()=>a});var e=s(303),t=s(846);const i=2*Math.PI,o={draw:!1,size:20,increment:.004,columns:0,rows:0,width:0,height:0,factor:{angle:.02,length:.01},offset:{x:4e4,y:4e4}};class r{constructor(){this._calculateField=()=>{const{field:e,noiseGen:t,options:o}=this,s=o.factor.length,n=o.factor.angle;for(let r=0;r<o.columns;r++){const a=e[r];for(let e=0;e<o.rows;e++){const l=a[e];l.length=t.noise3d(r*s+o.offset.x,e*s+o.offset.y,this.noiseZ),l.angle=t.noise3d(r*n,e*n,this.noiseZ)*i}}},this._drawField=e=>{const{field:t,options:i}=this;for(let o=0;o<i.columns;o++){const s=t[o];for(let t=0;t<i.rows;t++){const i=s[t],{angle:n,length:r}=i;e.setTransform(1,0,0,1,o*this.options.size,t*this.options.size),e.rotate(n),e.strokeStyle="white",e.beginPath(),e.moveTo(0,0),e.lineTo(0,this.options.size*r),e.stroke(),e.setTransform(1,0,0,1,0,0)}}},this._initField=()=>{const{columns:t,rows:i}=this.options;this.field=new Array(t);for(let o=0;o<t;o++){this.field[o]=new Array(i);for(let t=0;t<i;t++)this.field[o][t]=e.Vector.origin}},this.noiseGen=new t.PerlinNoise,this.field=[],this.noiseZ=0,this.options=(0,e.deepExtend)({},o)}generate(t){const i=t.getPosition(),{size:o}=this.options,s=Math.max(Math.floor(i.x/o),0),n=Math.max(Math.floor(i.y/o),0),{field:r}=this;return r?.[s]?.[n]?r[s][n].copy():e.Vector.origin}init(e){this.container=e,this._setup()}reset(){}update(){this.container&&(this._calculateField(),this.noiseZ+=this.options.increment,this.options.draw&&this.container.canvas.draw((e=>this._drawField(e))))}_resetField(){const t=this.container;if(!t)return;const i=t.actualOptions.particles.move.path.options,{options:s}=this;s.size=i.size>0?i.size:o.size,s.increment=i.increment>0?i.increment:o.increment,s.draw=!!i.draw;const n=i.offset;s.offset.x=n?.x??o.offset.x,s.offset.y=n?.y??o.offset.y;const r=i.factor;s.factor.angle=r?.angle??o.factor.angle,s.factor.length=r?.length??o.factor.length,s.width=t.canvas.size.width,s.height=t.canvas.size.height,this.options.seed=i.seed,this.noiseGen.seed(this.options.seed??(0,e.getRandom)()),s.columns=Math.floor(this.options.width/this.options.size)+1,s.rows=Math.floor(this.options.height/this.options.size)+1,this._initField()}_setup(){this.noiseZ=0,this._resetField(),window.addEventListener("resize",(()=>this._resetField()))}}const a="perlinNoise";async function l(e,t=!0){await e.addPathGenerator(a,new r,t)}})(),n})()));