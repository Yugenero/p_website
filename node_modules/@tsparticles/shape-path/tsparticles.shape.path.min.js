/*! For license information please see tsparticles.shape.path.min.js.LICENSE.txt */
!function(e,a){if("object"==typeof exports&&"object"==typeof module)module.exports=a(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],a);else{var t="object"==typeof exports?a(require("@tsparticles/engine")):a(e.window);for(var s in t)("object"==typeof exports?exports:e)[s]=t[s]}}(this,(e=>(()=>{var a={303:a=>{a.exports=e}},t={};function s(e){var r=t[e];if(void 0!==r)return r.exports;var l=t[e]={exports:{}};return a[e](l,l.exports,s),l.exports}s.d=(e,a)=>{for(var t in a)s.o(a,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:a[t]})},s.o=(e,a)=>Object.prototype.hasOwnProperty.call(e,a),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{s.r(r),s.d(r,{loadPathShape:()=>l});var e,a=s(303);!function(e){e.line="line",e.bezier="bezier",e.quadratic="quadratic",e.arc="arc",e.ellipse="ellipse"}(e||(e={}));class t{constructor(){this.validTypes=["path"]}draw(a){const{context:t,particle:s,radius:r}=a;s.pathData&&function(a,t,s){const r=s.segments[0].values[0];a.moveTo(r.x*t,r.y*t);for(const r of s.segments){const s=r.values[0],l=1,o=2,i=3;switch(r.type){case e.line:a.lineTo(s.x*t,s.y*t);break;case e.bezier:a.bezierCurveTo(r.values[l].x*t,r.values[l].y*t,r.values[o].x*t,r.values[o].y*t,r.values[i].x*t,r.values[i].y*t);break;case e.quadratic:a.quadraticCurveTo(r.values[l].x*t,r.values[l].y*t,r.values[o].x*t,r.values[o].y*t);break;case e.arc:a.arc(s.x*t,s.y*t,r.values[l].x*t,r.values[o].x,r.values[o].y);break;case e.ellipse:a.ellipse(s.x*t,s.y*t,r.values[l].x*t,r.values[l].y*t,r.values[o].x,r.values[i].x,r.values[i].y)}}if(!s.half)return;for(let r=s.segments.length-1;r>=0;r--){const l=s.segments[r],o=l.values[0],i=1,u=2;switch(l.type){case e.line:a.lineTo(o.x*-t,o.y*t);break;case e.bezier:a.bezierCurveTo(-l.values[u].x*t,l.values[u].y*t,-l.values[i].x*t,l.values[i].y*t,o.x*t,o.y*t);break;case e.quadratic:a.quadraticCurveTo(-l.values[i].x*t,l.values[i].y*t,-l.values[u].x*t,l.values[u].y*t);case e.arc:case e.ellipse:}}}(t,r,s.pathData)}particleInit(e,t){const s=t.shapeData;s&&(t.pathData=(0,a.deepExtend)({},s))}}async function l(e,a=!0){await e.addShape(new t,a)}})(),r})()));