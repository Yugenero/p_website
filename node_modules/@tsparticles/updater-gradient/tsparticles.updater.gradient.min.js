/*! For license information please see tsparticles.updater.gradient.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],t);else{var a="object"==typeof exports?t(require("@tsparticles/engine")):t(e.window);for(var i in a)("object"==typeof exports?exports:e)[i]=a[i]}}(this,(e=>(()=>{var t={303:t=>{t.exports=e}},a={};function i(e){var n=a[e];if(void 0!==n)return n.exports;var o=a[e]={exports:{}};return t[e](o,o.exports,i),o.exports}i.d=(e,t)=>{for(var a in t)i.o(t,a)&&!i.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{loadGradientUpdater:()=>u});var e=i(303);class t{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1,this.startValue=e.StartValueType.random}load(t){t&&(void 0!==t.count&&(this.count=(0,e.setRangeValue)(t.count)),void 0!==t.enable&&(this.enable=t.enable),void 0!==t.speed&&(this.speed=(0,e.setRangeValue)(t.speed)),void 0!==t.sync&&(this.sync=t.sync),void 0!==t.startValue&&(this.startValue=t.startValue),void 0!==t.decay&&(this.decay=(0,e.setRangeValue)(t.decay)),void 0!==t.delay&&(this.delay=(0,e.setRangeValue)(t.delay)))}}class a{constructor(){this.value=0,this.animation=new t}load(t){t&&(this.animation.load(t.animation),void 0!==t.value&&(this.value=(0,e.setRangeValue)(t.value)))}}class o{constructor(){this.stop=0,this.value=new e.AnimatableColor}load(t){t&&(void 0!==t.stop&&(this.stop=t.stop),this.value=e.AnimatableColor.create(this.value,t.value),void 0!==t.opacity&&(this.opacity=new a,(0,e.isNumber)(t.opacity)?this.opacity.value=t.opacity:this.opacity.load(t.opacity)))}}class s{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1}load(t){t&&(void 0!==t.count&&(this.count=(0,e.setRangeValue)(t.count)),void 0!==t.enable&&(this.enable=t.enable),void 0!==t.speed&&(this.speed=(0,e.setRangeValue)(t.speed)),void 0!==t.decay&&(this.decay=(0,e.setRangeValue)(t.decay)),void 0!==t.delay&&(this.delay=(0,e.setRangeValue)(t.delay)),void 0!==t.sync&&(this.sync=t.sync))}}class l{constructor(){this.value=0,this.animation=new s,this.direction=e.RotateDirection.clockwise}load(t){t&&(this.animation.load(t.animation),void 0!==t.value&&(this.value=(0,e.setRangeValue)(t.value)),void 0!==t.direction&&(this.direction=t.direction))}}class r{constructor(){this.angle=new l,this.colors=[],this.type=e.GradientType.random}load(e){e&&(this.angle.load(e.angle),void 0!==e.colors&&(this.colors=e.colors.map((e=>{const t=new o;return t.load(e),t}))),void 0!==e.type&&(this.type=e.type))}}const c=2*Math.PI;class d{getColorStyles(t,a,i,n){const o=t.gradient;if(!o)return{};const s=o.angle.value,l=0,r=0,c=o.type===e.GradientType.radial?a.createRadialGradient(l,r,0,l,r,i):a.createLinearGradient(Math.cos(s)*-i,Math.sin(s)*-i,Math.cos(s)*i,Math.sin(s)*i);for(const{stop:t,value:a,opacity:i}of o.colors)c.addColorStop(t,(0,e.getStyleFromHsl)({h:a.h.value,s:a.s.value,l:a.l.value},i?.value??n));return{fill:c}}init(t){const a=(0,e.itemFromSingleOrMultiple)(t.options.gradient);if(!a)return;const{angle:i}=a;t.gradient={angle:{value:(0,e.getRangeValue)(i.value),enable:i.animation.enable,velocity:(0,e.getRangeValue)(i.animation.speed)/360*t.container.retina.reduceFactor,decay:1-(0,e.getRangeValue)(i.animation.decay),delayTime:(0,e.getRangeValue)(i.animation.delay)*e.millisecondsToSeconds,max:c,min:0,time:0},type:a.type,colors:[]};let n=a.angle.direction;switch(n===e.RotateDirection.random&&(n=(0,e.getRandom)()>e.halfRandom?e.RotateDirection.counterClockwise:e.RotateDirection.clockwise),n){case e.RotateDirection.counterClockwise:case"counterClockwise":t.gradient.angle.status=e.AnimationStatus.decreasing;break;case e.RotateDirection.clockwise:t.gradient.angle.status=e.AnimationStatus.increasing}const o=t.options.reduceDuplicates;for(const i of a.colors){const a=(0,e.rangeColorToHsl)(i.value,t.id,o);if(!a)continue;const n=(0,e.getHslAnimationFromHsl)(a,i.value.animation,t.container.retina.reduceFactor),s={stop:i.stop,value:n,opacity:i.opacity?{enable:i.opacity.animation.enable,max:(0,e.getRangeMax)(i.opacity.value),min:(0,e.getRangeMin)(i.opacity.value),status:e.AnimationStatus.increasing,value:(0,e.getRangeValue)(i.opacity.value),velocity:(0,e.getRangeValue)(i.opacity.animation.speed)/e.percentDenominator*t.container.retina.reduceFactor,decay:1-(0,e.getRangeValue)(i.opacity.animation.decay),delayTime:(0,e.getRangeValue)(i.opacity.animation.delay)*e.millisecondsToSeconds,time:0}:void 0},{opacity:l}=s;if(i.opacity&&l){const t=i.opacity.value;l.min=(0,e.getRangeMin)(t),l.max=(0,e.getRangeMax)(t);switch(i.opacity.animation.startValue){case e.StartValueType.min:l.value=l.min,l.status=e.AnimationStatus.increasing;break;case e.StartValueType.max:l.value=l.max,l.status=e.AnimationStatus.decreasing;break;case e.StartValueType.random:default:l.value=(0,e.randomInRange)(l),l.status=(0,e.getRandom)()>=e.halfRandom?e.AnimationStatus.increasing:e.AnimationStatus.decreasing}}t.gradient.colors.push(s)}}isEnabled(e){return!e.destroyed&&!e.spawning&&(!!e.gradient?.angle.enable||(e.gradient?.colors.some((e=>e.value.h.enable||e.value.s.enable||e.value.l.enable))??!1))}loadOptions(t,...a){for(const i of a){if(!i?.gradient)continue;const a=i.gradient;a&&(t.gradient=(0,e.executeOnSingleOrMultiple)(a,(e=>{const t=new r;return t.load(e),t})))}}update(t,a){!function(t,a){const{gradient:i}=t;if(i){(0,e.updateAnimation)(t,i.angle,!1,e.DestroyType.none,a);for(const n of i.colors)(0,e.updateColor)(n.value,a),n.opacity&&(0,e.updateAnimation)(t,n.opacity,!0,e.DestroyType.none,a)}}(t,a)}}async function u(e,t=!0){await e.addParticleUpdater("gradient",(()=>Promise.resolve(new d)),t)}})(),n})()));