"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Repulser = void 0;
const engine_1 = require("@tsparticles/engine");
const ParticlesRepulse_js_1 = require("./Options/Classes/ParticlesRepulse.js");
const minDistance = 0, identity = 1, squareExp = 2, minVelocity = 0;
class Repulser extends engine_1.ParticlesInteractorBase {
    constructor(container) {
        super(container);
    }
    clear() {
    }
    init() {
    }
    interact(p1) {
        const container = this.container;
        if (!p1.repulse) {
            const repulseOpt1 = p1.options.repulse;
            if (!repulseOpt1) {
                return;
            }
            p1.repulse = {
                distance: (0, engine_1.getRangeValue)(repulseOpt1.distance) * container.retina.pixelRatio,
                speed: (0, engine_1.getRangeValue)(repulseOpt1.speed),
                factor: (0, engine_1.getRangeValue)(repulseOpt1.factor),
            };
        }
        const pos1 = p1.getPosition(), query = container.particles.quadTree.queryCircle(pos1, p1.repulse.distance);
        for (const p2 of query) {
            if (p1 === p2 || p2.destroyed) {
                continue;
            }
            const pos2 = p2.getPosition(), { dx, dy, distance } = (0, engine_1.getDistances)(pos2, pos1), velocity = p1.repulse.speed * p1.repulse.factor;
            if (distance > minDistance) {
                const repulseFactor = (0, engine_1.clamp)((identity - Math.pow(distance / p1.repulse.distance, squareExp)) * velocity, minVelocity, velocity), normVec = engine_1.Vector.create((dx / distance) * repulseFactor, (dy / distance) * repulseFactor);
                p2.position.addTo(normVec);
            }
            else {
                const velocityVec = engine_1.Vector.create(velocity, velocity);
                p2.position.addTo(velocityVec);
            }
        }
    }
    isEnabled(particle) {
        return particle.options.repulse?.enabled ?? false;
    }
    loadParticlesOptions(options, ...sources) {
        if (!options.repulse) {
            options.repulse = new ParticlesRepulse_js_1.ParticlesRepulse();
        }
        for (const source of sources) {
            options.repulse.load(source?.repulse);
        }
    }
    reset() {
    }
}
exports.Repulser = Repulser;
