/*! For license information please see tsparticles.interaction.light.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var r=o[t];if(void 0!==r)return r.exports;var s=o[t]={exports:{}};return e[t](s,s.exports,i),s.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{i.r(r),i.d(r,{Light:()=>u,LightArea:()=>d,LightGradient:()=>c,LightShadow:()=>h,loadLightInteraction:()=>f});var t=i(303);const e=1,o=0,s=.5*Math.PI,n=2*Math.PI,a=.25*Math.PI,l="light";class c{constructor(){this.start=new t.OptionsColor,this.stop=new t.OptionsColor,this.start.value="#ffffff",this.stop.value="#000000"}load(e){e&&(this.start=t.OptionsColor.create(this.start,e.start),this.stop=t.OptionsColor.create(this.stop,e.stop))}}class d{constructor(){this.gradient=new c,this.radius=1e3}load(t){t&&(this.gradient.load(t.gradient),void 0!==t.radius&&(this.radius=t.radius))}}class h{constructor(){this.color=new t.OptionsColor,this.color.value="#000000",this.length=2e3}load(e){e&&(this.color=t.OptionsColor.create(this.color,e.color),void 0!==e.length&&(this.length=e.length))}}class u{constructor(){this.area=new d,this.shadow=new h}load(t){t&&(this.area.load(t.area),this.shadow.load(t.shadow))}}class p extends t.ExternalInteractorBase{constructor(t){super(t)}clear(){}init(){}interact(){const i=this.container,r=i.actualOptions,s=i.interactivity;if(!r.interactivity.events.onHover.enable||"pointermove"!==s.status)return;const a=s.mouse.position;a&&i.canvas.draw((r=>{!function(i,r,s){const a=i.actualOptions.interactivity.modes.light?.area;if(!a)return;r.beginPath(),r.arc(s.x,s.y,a.radius,0,n);const l=r.createRadialGradient(s.x,s.y,0,s.x,s.y,a.radius),c=i.canvas.mouseLight;c?.start&&c.stop&&(l.addColorStop(o,(0,t.getStyleFromRgb)(c.start)),l.addColorStop(e,(0,t.getStyleFromRgb)(c.stop)),r.fillStyle=l,r.fill())}(i,r,a)}))}isEnabled(e){const o=this.container,i=o.interactivity.mouse,r=e?.interactivity??o.actualOptions.interactivity,s=r.events;if(!s.onHover.enable||!i.position)return!1;const n=(0,t.isInArray)(l,s.onHover.mode);if(n&&r.modes.light){const e=r.modes.light.area.gradient;o.canvas.mouseLight={start:(0,t.rangeColorToRgb)(e.start),stop:(0,t.rangeColorToRgb)(e.stop)}}return n}loadModeOptions(t,...e){t.light||(t.light=new u);for(const o of e)t.light.load(o?.light)}reset(){}}class g extends t.ParticlesInteractorBase{constructor(t){super(t)}clear(){}init(){}interact(e){const o=this.container,i=o.actualOptions,r=o.interactivity;if(!i.interactivity.events.onHover.enable||"pointermove"!==r.status)return;const l=r.mouse.position;l&&o.canvas.draw((i=>{!function(e,o,i,r){const l=i.getPosition(),c=e.actualOptions.interactivity.modes.light?.shadow;if(!c)return;const d=i.lightShadow;if(!d)return;const h=i.getRadius(),u=i.sides,p=n/u,g=-i.rotation+a,f=[];for(let t=0;t<u;t++)f.push({x:l.x+h*Math.sin(g+p*t)*1,y:l.y+h*Math.cos(g+p*t)*1});const v=[],y=c.length;for(const t of f){const e=Math.atan2(r.y-t.y,r.x-t.x),o={x:t.x+y*Math.sin(-e-s),y:t.y+y*Math.cos(-e-s)};v.push({end:o,start:t})}const m=(0,t.getStyleFromRgb)(d);for(let t=v.length-1,e=0;t>=0;e=t--)o.beginPath(),o.moveTo(v[t].start.x,v[t].start.y),o.lineTo(v[e].start.x,v[e].start.y),o.lineTo(v[e].end.x,v[e].end.y),o.lineTo(v[t].end.x,v[t].end.y),o.fillStyle=m,o.fill()}(o,i,e,l)}))}isEnabled(e){const o=this.container,i=e.interactivity??o.actualOptions.interactivity,r=o.interactivity.mouse,s=i.events;if(!s.onHover.enable||!r.position)return!1;const n=(0,t.isInArray)(l,s.onHover.mode);if(n&&i.modes.light){const o=i.modes.light.shadow;e.lightShadow=(0,t.rangeColorToRgb)(o.color)}return n}reset(){}}async function f(t,e=!0){await t.addInteractor("externalLight",(t=>Promise.resolve(new p(t))),e),await t.addInteractor("particlesLight",(t=>Promise.resolve(new g(t))),e)}})(),r})()));