(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@tsparticles/engine", "./Options/Classes/AnimatableGradient.js", "./Utils.js"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GradientUpdater = void 0;
    const engine_1 = require("@tsparticles/engine");
    const AnimatableGradient_js_1 = require("./Options/Classes/AnimatableGradient.js");
    const Utils_js_1 = require("./Utils.js");
    const double = 2, doublePI = Math.PI * double;
    class GradientUpdater {
        getColorStyles(particle, context, radius, opacity) {
            const gradient = particle.gradient;
            if (!gradient) {
                return {};
            }
            const gradientAngle = gradient.angle.value, origin = { x: 0, y: 0 }, minRadius = 0, fillGradient = gradient.type === engine_1.GradientType.radial
                ? context.createRadialGradient(origin.x, origin.y, minRadius, origin.x, origin.y, radius)
                : context.createLinearGradient(Math.cos(gradientAngle) * -radius, Math.sin(gradientAngle) * -radius, Math.cos(gradientAngle) * radius, Math.sin(gradientAngle) * radius);
            for (const { stop, value, opacity: cOpacity } of gradient.colors) {
                fillGradient.addColorStop(stop, (0, engine_1.getStyleFromHsl)({
                    h: value.h.value,
                    s: value.s.value,
                    l: value.l.value,
                }, cOpacity?.value ?? opacity));
            }
            return { fill: fillGradient };
        }
        init(particle) {
            const gradient = (0, engine_1.itemFromSingleOrMultiple)(particle.options.gradient);
            if (!gradient) {
                return;
            }
            const { angle } = gradient, speedFactor = 360, delayOffset = 1;
            particle.gradient = {
                angle: {
                    value: (0, engine_1.getRangeValue)(angle.value),
                    enable: angle.animation.enable,
                    velocity: ((0, engine_1.getRangeValue)(angle.animation.speed) / speedFactor) * particle.container.retina.reduceFactor,
                    decay: delayOffset - (0, engine_1.getRangeValue)(angle.animation.decay),
                    delayTime: (0, engine_1.getRangeValue)(angle.animation.delay) * engine_1.millisecondsToSeconds,
                    max: doublePI,
                    min: 0,
                    time: 0,
                },
                type: gradient.type,
                colors: [],
            };
            let rotateDirection = gradient.angle.direction;
            if (rotateDirection === engine_1.RotateDirection.random) {
                rotateDirection = (0, engine_1.getRandom)() > engine_1.halfRandom ? engine_1.RotateDirection.counterClockwise : engine_1.RotateDirection.clockwise;
            }
            switch (rotateDirection) {
                case engine_1.RotateDirection.counterClockwise:
                case "counterClockwise":
                    particle.gradient.angle.status = engine_1.AnimationStatus.decreasing;
                    break;
                case engine_1.RotateDirection.clockwise:
                    particle.gradient.angle.status = engine_1.AnimationStatus.increasing;
                    break;
            }
            const reduceDuplicates = particle.options.reduceDuplicates;
            for (const grColor of gradient.colors) {
                const grHslColor = (0, engine_1.rangeColorToHsl)(grColor.value, particle.id, reduceDuplicates);
                if (!grHslColor) {
                    continue;
                }
                const grHslAnimation = (0, engine_1.getHslAnimationFromHsl)(grHslColor, grColor.value.animation, particle.container.retina.reduceFactor), addColor = {
                    stop: grColor.stop,
                    value: grHslAnimation,
                    opacity: grColor.opacity
                        ? {
                            enable: grColor.opacity.animation.enable,
                            max: (0, engine_1.getRangeMax)(grColor.opacity.value),
                            min: (0, engine_1.getRangeMin)(grColor.opacity.value),
                            status: engine_1.AnimationStatus.increasing,
                            value: (0, engine_1.getRangeValue)(grColor.opacity.value),
                            velocity: ((0, engine_1.getRangeValue)(grColor.opacity.animation.speed) / engine_1.percentDenominator) *
                                particle.container.retina.reduceFactor,
                            decay: delayOffset - (0, engine_1.getRangeValue)(grColor.opacity.animation.decay),
                            delayTime: (0, engine_1.getRangeValue)(grColor.opacity.animation.delay) * engine_1.millisecondsToSeconds,
                            time: 0,
                        }
                        : undefined,
                };
                const { opacity: addOpacity } = addColor;
                if (grColor.opacity && addOpacity) {
                    const opacityRange = grColor.opacity.value;
                    addOpacity.min = (0, engine_1.getRangeMin)(opacityRange);
                    addOpacity.max = (0, engine_1.getRangeMax)(opacityRange);
                    const opacityAnimation = grColor.opacity.animation;
                    switch (opacityAnimation.startValue) {
                        case engine_1.StartValueType.min:
                            addOpacity.value = addOpacity.min;
                            addOpacity.status = engine_1.AnimationStatus.increasing;
                            break;
                        case engine_1.StartValueType.max:
                            addOpacity.value = addOpacity.max;
                            addOpacity.status = engine_1.AnimationStatus.decreasing;
                            break;
                        case engine_1.StartValueType.random:
                        default:
                            addOpacity.value = (0, engine_1.randomInRange)(addOpacity);
                            addOpacity.status =
                                (0, engine_1.getRandom)() >= engine_1.halfRandom ? engine_1.AnimationStatus.increasing : engine_1.AnimationStatus.decreasing;
                            break;
                    }
                }
                particle.gradient.colors.push(addColor);
            }
        }
        isEnabled(particle) {
            return (!particle.destroyed &&
                !particle.spawning &&
                (!!particle.gradient?.angle.enable ||
                    (particle.gradient?.colors.some(c => c.value.h.enable || c.value.s.enable || c.value.l.enable) ??
                        false)));
        }
        loadOptions(options, ...sources) {
            for (const source of sources) {
                if (!source?.gradient) {
                    continue;
                }
                const gradientToLoad = source.gradient;
                if (!gradientToLoad) {
                    continue;
                }
                options.gradient = (0, engine_1.executeOnSingleOrMultiple)(gradientToLoad, gradient => {
                    const tmp = new AnimatableGradient_js_1.AnimatableGradient();
                    tmp.load(gradient);
                    return tmp;
                });
            }
        }
        update(particle, delta) {
            (0, Utils_js_1.updateGradient)(particle, delta);
        }
    }
    exports.GradientUpdater = GradientUpdater;
});
